<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="mfswtest">mfsw_test</h1>
<p><code>mfsw_test</code> is a test directory for running a program, <code>test.cpp</code>,
built by applying the mean-field theory and spin-wave theory to the general localized interaction model,
$$
\mathcal{H} \ = \ \sum_{\braket{ij}} \sum_{\xi\xi^\prime} I_{ij}^{\xi\xi^\prime} \mathcal{O}_i^{\xi} \mathcal{O}_j^{\xi^\prime}</p>
<ul>
<li>\sum_{i}\sum_{\xi} H_i^\xi \mathcal{O}_{i}^\xi
\ = \ \mathcal{H}^{\text{MF}} + \mathcal{H}^\prime.
$$</li>
</ul>
<!-- By using following relation,
$\mathcal{O}_{i}^{\xi} = \braket{\mathcal{O}^\xi}_{\text{MF}:C_i} + \delta\mathcal{O}_i^\xi$,
where $C_i$ is the sublattice of the site $i$,  -->
<p>One can calculate as following quantities.</p>
<ul>
<li>Local state</li>
<li>Spin-wave dispersion</li>
<li>Dynamical structure factor $S(\mathbf{q},\omega)$</li>
<li>Moment contraction (or SW moment)</li>
<li>Quasiparticle damping rate</li>
</ul>
<p>As for the dynamical structure factor, in the linear spin-wave theory, $S_{\xi\xi^\prime}(\mathbf{q},\omega)$ is expressed by
$$
S_{\xi\xi^\prime} (\mathbf{q},\omega)
\ = <br>
\sum_{\eta}^{N} \tilde{W}<em>{\eta,\mathbf{q}}^{\xi} \tilde{W}</em>{\eta,\mathbf{q}}^{\xi^\prime*}
\delta (\omega - \varepsilon_{\eta,\mathbf{q}}),
$$
where, N is a number of spin-wave bands and
$\varepsilon_{\eta,\mathbf{q}}$ is the excitation energy for the $\eta$-th band.</p>
<p>On the program, all $\tilde{W}_{\eta,\mathbf{q}}^{\xi}$ are calculated and
written to a file opened by <code>std::ofstream</code>.</p>
<h1 id="overview">Overview</h1>
<p>Below is the code to calculate the mean-field solution, spin-wave dispersion,
SW moments, and dynamical structure factor.</p>
<pre class="hljs"><code><div>
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &quot;cpplapack/cpplapack.h&quot;

using namespace std;


#include &quot;mfsw.hpp&quot;
#include &quot;makedata.hpp&quot;

using exch_type = CPPL::dgematrix;
struct param 
{
  vector&lt;tuple&lt;vector&lt;double&gt;, exch_type&gt;&gt; J;
  vector&lt;vector&lt;double&gt;&gt; H;
  double T;
};

void bond(int n, int Nc, int i, int j, const vector&lt;double&gt; &amp;xs, mfsw&lt;exch_type&gt;&amp; ms, 
          param &amp;p)
{
  int m;
  exch_type Js;
  for (int i = 0; i &lt; p.J.size(); i++)
  {
    vector&lt;double&gt; x = std::get&lt;0&gt;(p.J[i]);
    double sum = 0.;
    for (int k = 0; k &lt; xs.size(); k++)
      sum += abs(x[k] - xs[k]);
    double eps = 1e-4;
    if (sum &lt; eps)
    {
      m = i;
      Js = std::get&lt;1&gt;(p.J[m]);
      break;
    }
    else 
    {
      Js.resize(Nc, Nc); Js.zero();
    }
  }
  ms.set_J(n) = std::tuple&lt;int, int, exch_type&gt;{i, j, Js};
}


int main(int argc, char *argv[])
{
  if(argc!=1) 
    exit(1);

  std::string fn_lattice = &quot;data/input/spin_wave_230203/cubic2subbcc_lattice.dat&quot;;
  std::string fn_iij = &quot;data/input/spin_wave_230203/cubic2subbcc_iij_1_1.dat&quot;;
  std::string fn_base = &quot;data/input/spin_wave_230203/cubic2subbcc_base_1_1.dat&quot;;

  makedata&lt;exch_type&gt; md(fn_lattice, fn_iij, fn_base);

  complex&lt;double&gt; im(0, 1);

  int Ns = md.make_Ns();       // 局所状態の数  (generator の次元)
  int Nc = md.make_Nc();       // サイトあたりの平均場の数
  int M = 2;                   // 副格子の数
  int N = M * Nc;              // 平均場の数
  int Z = 8;                   // １つの注目サイトと相互作用するサイトの合計（最近接間でのみ相互作用する bcc なら　8）
  int Nb = M * Z/2;            // ユニットセルに含まれるボンドの総数
  int Nr = 5;                  // 初期値を（ランダムに）入力する回数
  int Ni = 100000;             // ループ回数



  ////*generator*////
  vector&lt;CPPL::zhematrix&gt; Oop(Nc);   // generator
  for (int i = 0; i &lt; Oop.size(); i++)
    Oop[i] = md.make_generator()[i];


  param p;
  md.make_J(p.J);
  md.make_H(p.H, M);

  mfsw&lt;exch_type&gt; ms(N, Nc, Nb, Ni, Nr, 1e-8);

  for (size_t i = 0; i &lt; N; i += Nc)
  {
    for (size_t j = 0; j &lt; Nc; j++)
      ms.set_mat(i + j) = Oop[j];
  }

  for(size_t i = 0; i &lt; N; i += Nc)
  {
    for (size_t j = 0; j &lt; Nc; j++)
    {
      ms.set_H(i + j) = p.H[i / Nc][j];
    }
  }


  vector&lt;vector&lt;double&gt;&gt; xs(Nb);   // ユニットセル内の独立なボンド間の相対座標

  /* bond input */
  {
    ms.set_bond(xs, Nb, md);       // 元データと同じ副格子構造を仮定していれば md.set_bond を呼び出すだけで良い
  }

  ms.exec_mf();                    // Nr 回のランダムな初期値で解を探す
  cout &lt;&lt; &quot;# &quot;;
  cout &lt;&lt; ms.mf_out() &lt;&lt; endl;     // 平均場解の出力（Nr回実行した内の最安定解のみ出力される）




  p.T = 1e-4;                      // System の温度
  ms.set_T() = p.T;
  std::function&lt;complex&lt;double&gt;(vector&lt;double&gt;, vector&lt;double&gt;)&gt; g_;
  g_ = [&amp;im](vector&lt;double&gt; x, vector&lt;double&gt; k)
  { 
    complex&lt;double&gt; pd(1);
    for (int i = 0; i &lt; x.size(); i++)
      pd = pd * exp(im * x[i] * k[i]);

    return pd;
  };

  vector&lt;std::function&lt;complex&lt;double&gt;(vector&lt;double&gt;, vector&lt;double&gt;)&gt;&gt; g(Nb);
  for (size_t i = 0; i &lt; Nb; i++)
    g[i] = g_;

  vector&lt;vector&lt;double&gt;&gt; a(3);         // 基本並進ベクトル
  md.make_unitvec(a);

  std::string fnsw = &quot;data/output/spec.txt&quot;;
  std::ofstream sw(fnsw);

  {    
    double x = 0.;
    double t = 0.;

    /* (-2π,-2π,-2π) --- (2π,2π,2π) line */
    for (x = -2.; x &lt; 2.001; x += 0.005)
    {
      vector&lt;double&gt; k(3);
      k[0] = x;
      k[1] = x;
      k[2] = x;
      k[0] *= M_PI;
      k[1] *= M_PI;
      k[2] *= M_PI;
      vector&lt;complex&lt;double&gt;&gt; gamma(g.size());
      for (int i = 0; i &lt; Nb; i++)
        gamma[i] = g[i](xs[i], k);
      sw &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; ms.exec_sw_out(gamma);   // スピン波エネルギーおよび動的構造因子の書き込み
      sw &lt;&lt; endl;
    }
    t = x;
  }

  std::string fnmg =  &quot;data/output/swmag.txt&quot;;
  std::ofstream mg(fnmg);
  {
    double dk = 0.05;
    mg &lt;&lt; &quot; &quot; &lt;&lt; ms.exec_sw_mag_out(xs, g, a, dk) &lt;&lt; endl;  // SW モーメントの書き込み
  }

}
</div></code></pre>
<p>Note the following:</p>
<h3 id="1-cout--msmfout--endl-outputs-in-the-following-order">1. <code>cout &lt;&lt; ms.mf_out() &lt;&lt; endl;</code>  outputs in the following order:</h3>
<p>$$
\begin{align}
&amp;E_{\text{gs}}, \nonumber\
&amp;\braket{\mathcal{O}^{\xi=0}}<em>{A}, \ \braket{\mathcal{O}^{\xi=1}}</em>{A}, \cdots, \ \braket{\mathcal{O}^{\xi=\xi_{\text{max}}}}<em>{A},\
\braket{\mathcal{O}^{\xi=0}}</em>{B}, \ \cdots, \ \braket{\mathcal{O}^{\xi=\xi_{\text{max}}}}<em>{B}, <br>
\braket{\mathcal{O}^{\xi=0}}</em>{C}, \ \cdots \nonumber
\end{align}
$$
where, capital alphabets represent sublattices.
As an example, for the data of <code>&quot;cubic2subbcc&quot;</code>, the output is as follows.</p>
<pre class="hljs"><code><div>#  -1.00000e+00   
0.7071067973 0.5845336644 -0.0056875930 -0.3978543406 0.7071066436 -0.5845336470 0.0056875929 0.3978543288 
</div></code></pre>
<h3 id="2-sw--x--%22-%22--msexecswoutgamma-write-out-in-fnsw-in-the-following-order">2. <code>sw &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; ms.exec_sw_out(gamma);</code>  write out in  <code>fnsw</code> in the following order:</h3>
<p>$$
\begin{align}
&amp;x,<br>
\varepsilon_{0,\mathbf{q}},\ \varepsilon_{1,\mathbf{q}}, \cdots, \varepsilon_{N,\mathbf{q}},\
\Big|\tilde{W}<em>{0,\mathbf{q}}^{\xi=0}\Big|^2, \Big|\tilde{W}</em>{1,\mathbf{q}}^{\xi=0}\Big|^2 ,\cdots ,\Big|\tilde{W}<em>{N,\mathbf{q}}^{\xi=0}\Big|^2,\
\Big|\tilde{W}</em>{0,\mathbf{q}}^{\xi=1}\Big|^2, \Big|\tilde{W}<em>{1,\mathbf{q}}^{\xi=1}\Big|^2 ,\cdots ,\Big|\tilde{W}</em>{N,\mathbf{q}}^{\xi=1}\Big|^2,\ \cdots\cdots\cdots\cdots,
\Big|\tilde{W}<em>{0,\mathbf{q}}^{\xi=\xi</em>{\text{max}}}\Big|^2, \Big|\tilde{W}<em>{1,\mathbf{q}}^{\xi=\xi</em>{\text{max}}}\Big|^2 ,\cdots ,\Big|\tilde{W}<em>{N,\mathbf{q}}^{\xi=\xi</em>{\text{max}}}\Big|^2
\nonumber\
&amp; ,\text{Re} (\text{off-diagonal terms}),\ \text{Im}(\text{off-diagonal terms})
\nonumber
\end{align}
$$</p>
<h3 id="3-mg--%22-%22--msexecswmagoutxs-g-a-dk--endl-write-out-in-fnmg-in-the-following-order">3. <code>mg &lt;&lt; &quot; &quot; &lt;&lt; ms.exec_sw_mag_out(xs, g, a, dk) &lt;&lt; endl;</code>  write out in  <code>fnmg</code> in the following order:</h3>
<p>$$
\newcommand{\bbraket}[1]{\langle\langle#1\rangle\rangle}
\begin{align}
&amp;\bbraket{\mathcal{O}^{\xi=0}}<em>{A}, \ \bbraket{\mathcal{O}^{\xi=1}}</em>{A}, \cdots, \ \bbraket{\mathcal{O}^{\xi=\xi_{\text{max}}}}<em>{A},\
\bbraket{\mathcal{O}^{\xi=0}}</em>{B}, \ \cdots, \ \bbraket{\mathcal{O}^{\xi=\xi_{\text{max}}}}<em>{B}, <br>
\bbraket{\mathcal{O}^{\xi=0}}</em>{C}, \ \cdots \nonumber
\end{align}
$$
where, $\langle\langle ~\cdot~ \rangle\rangle$ is the expectation value in Bogoliubov vacuum.</p>
<h1 id="interfaces">Interfaces</h1>
<p><code>makedata.hpp</code> and <code>mfsw.hpp</code> provide one interface each.</p>
<h3 id="%E3%83%BBmakedata">・makedata</h3>
<p>The primary role of <code>makedata</code> class is to produce
$\mathcal{O}<em>i$, $I</em>{ij}$, $H_{i}$, and the primitive lattice vector from the original data.</p>
<h3 id="%E3%83%BBmfsw">・mfsw</h3>
<p>'mfsw' class computes the mean-field solution and above quauntities.
In the mean-field solution, we can change the initial values to file read.</p>
<p>For example, we prepare the initial value input file</p>
<pre class="hljs"><code><div>0.7071067812 0 0 0.7071067812  0.7071067812 0 0 -0.7071067812
</div></code></pre>
<p>and change <code>ms.exec_mf()</code> to the following.</p>
<pre class="hljs"><code><div>ms.exec_mf(&quot;data/input/init.txt&quot;);
</div></code></pre>
<p>As a result, the output is as follows.</p>
<pre class="hljs"><code><div>#  -1.00000e+00   
0.7071067812 0.0000000000 0.0000000000 0.7071067812 0.7071067812 0.0000000000 0.0000000000 -0.7071067812 
</div></code></pre>
<p>Note that if you put some initial values, it will solve a self-consistent equation for the number of initial values.</p>
<h1 id="graphics">Graphics</h1>
<p>The spin-wave dispersion and dynamical structure factor are plotted by
<code>sw.py</code> and <code>spec.py</code>.
These python codes use command-line arguments.
Run these codes as follows:</p>
<pre class="hljs"><code><div>$ python sw.py M Ne
$ python spec.py M Ne
</div></code></pre>
<p>Here, M is total number of sublattices and Ne is total number of local excited states.
For <code>&quot;cubic2subbcc&quot;</code>, we type as</p>
<pre class="hljs"><code><div>$ python sw.py 2 1
$ python spec.py 2 1
</div></code></pre>
<h1 id="requirement">Requirement</h1>
<ul>
<li>
<p>C++11 compatible environment</p>
</li>
<li>
<p>cpplapack-2015.05.11 (header-only library)</p>
</li>
</ul>

</body>
</html>
